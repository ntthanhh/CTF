# PHP Type Juggling
```php
<?php

      if (isset($_POST['password'])) {
        if (strcmp($_POST['password'], $password) == 0) {
          echo $FLAG;
        } else {
          echo '<br/>Wrong Password<br/><br/>';
        }
      }

?>
```
Có, đoạn code này chứa một lỗ hổng kinh điển trong PHP liên quan đến hàm `strcmp()` khi xử lý các phiên bản PHP cũ (thường là < 8.0), được gọi là PHP Type Juggling (Lỗ hổng ép kiểu).
**1. Nguyên nhân lỗ hổng**
Vấn đề nằm ở dòng code này:
<pre>if (strcmp($_POST['password'], $password) == 0)</pre>
Hàm `strcmp($string1, $string2)` được dùng để so sánh hai chuỗi:
* Nếu chuỗi giống nhau, nó trả về 0.
* Nếu khác nhau, nó trả về một số lớn hơn hoặc nhỏ hơn 0.

Tuy nhiên, lỗ hổng xảy ra khi bạn truyền vào một Mảng (Array) thay vì một Chuỗi (String):
* Trong các phiên bản PHP cũ (trước 8.0), nếu bạn truyền một mảng vào `strcmp()`, hàm này không biết cách xử lý nên sẽ đưa ra một cảnh báo (Warning) và trả về giá trị `NULL`.
* Đoạn code sử dụng toán tử so sánh lỏng lẻo `==` (thay vì so sánh chặt chẽ `===`).
* Trong PHP, biểu thức `NULL == 0` sẽ trả về kết quả là `TRUE`.

**2. Cách khai thác**
Để khai thác, bạn cần làm cho `$_POST['password']` trở thành một mảng thay vì một chuỗi.
Cách làm: Thay đổi tham số gửi lên server từ `password` thành `password[]`.
<pre>Payload : password[] = test</pre>

---

```php
<?php

if (isset($_GET['input'])){
    $user_input = $_GET['input'];

    if ($user_input == substr(md5($user_input), 0, 24)){
        echo "flag: $flag";
    } else{
        echo "Nope nope nope";
    }
}

?>
```

**1. Lỗ hổng**
Vấn đề nằm ở phép so sánh `==`. Trong PHP:
* Nếu một chuỗi bắt đầu bằng `0e` theo sau là toàn các chữ số (ví dụ: `0e12345`), PHP sẽ coi đó là ký hiệu khoa học (Scientific Notation).
* ```0e123``` có nghĩa là $0 \times 10^{123}$, giá trị bằng 0.
* Khi so sánh bằng `==`, nếu cả hai vế đều có dạng `0e...` (chỉ chứa số sau `0e`), PHP sẽ chuyển cả hai về số 0 (float) để so sánh.
* Kết quả: `0 == 0` là TRUE.

**2. Cách giải**
Bạn cần tìm một chuỗi `$user_input` thỏa mãn 2 điều kiện:
* Bản thân chuỗi đó bắt đầu bằng `0e` và theo sau là số.
* Mã băm MD5 của nó cũng bắt đầu bằng `0e` và theo sau là số (ít nhất là trong 24 ký tự đầu).

Đây là một trường hợp nổi tiếng được gọi là Magic Hash trong PHP. Chuỗi phổ biến nhất để vượt qua bài này là:
<pre>Payload : 0e215962017</pre>

---

```php
<?php

if(!isset($_GET["tema"])) $path = "light.css";  
else {
    $path = $_GET["tema"];
    if (preg_match("/..\//", $path)) {  
        $path = str_replace('../', './' , $path);
        
        $error = false;
        $arr = explode(".", $path);
        $estensione = $arr[count($arr)-1];

        if($estensione != "css"){
            $error = true;
            $path = substr($path, 0, -3) . "css";
        }
    }
}
$css = "static/css/" . $path;

?>
```
**1. Giải thích lỗ hổng**
**A**. Lỗ hổng Bypass `str_replace` (Để leo thư mục)
Server sử dụng dòng code này để chặn bạn leo ra thư mục cha:
```php
$path = str_replace('../', './' , $path);
```
Nó sẽ tìm chuỗi `../` và đổi thành `./.` Tuy nhiên, nó chỉ quét 1 lần duy nhất (không đệ quy).
* Nếu bạn nhập: `../` $\rightarrow$ Server đổi thành `./` (Thất bại, không leo được).
* Nếu bạn nhập (Payload chuẩn): `.../` $\rightarrow$ Server xử lý như sau:
  1. Nó nhìn vào `.../`.
  2. Nó phát hiện cụm `../` nằm ở phía sau (từ ký tự thứ 2 đến thứ 4).
  3. Nó thay thế cụm `../` đó bằng `./`.
  4. Dấu chấm `.` đầu tiên không bị động chạm nên vẫn giữ nguyên.
  5. Kết quả: `.` (đầu) + `./` (vừa thay) = `../`

$\rightarrow$ Thành công: Chúng ta đã tạo lại được chuỗi `../` sau khi qua bộ lọc.

**B**. Lỗ hổng Null Byte (Để đọc file đuôi bất kỳ)
Server ép buộc file phải có đuôi `.css` : 
```php
if($estensione != "css") { ...thêm đuôi css... }
```
Chúng ta dùng Null Byte `(%00)` để đánh lừa :
* Với PHP: Chuỗi `flag.txt%00.css` có đuôi là `.css`. $\rightarrow$ Hợp lệ, server không tự động chèn thêm đuôi nữa.
* Với Hệ điều hành (Linux): Khi đọc file, nó gặp ký tự `%00` (ký tự kết thúc chuỗi), nó sẽ vứt bỏ toàn bộ phần đằng sau. Nó chỉ mở file `flag.txt`.

**2. Payload hoàn chỉnh**
Giả sử file `flag.txt` nằm ở thư mục gốc `(root)`, bạn cần leo lên khoảng 3-5 cấp thư mục để chắc chắn chạm tới gốc.
<pre>Payload : .../.../.../.../.../flag.txt%00.css</pre> 